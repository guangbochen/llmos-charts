# Default values for dify.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.
global:
  ## @param global.imageRegistry Global Docker image registry
  ##
  imageRegistry: ""
  ## @param global.imagePullSecrets Global Docker registry secret names as an array
  ## e.g.
  ## imagePullSecrets:
  ##   - myRegistryKeySecretName
  ##
  imagePullSecrets: []
  auth:
    defaultPassword: &defaultPassword "difyai123456"
    secretKye: &secretKye "sk-B43OG4q2e+bnP6El4TatUpsPUS9NZD9fSOpvJ0Wiq4xpBHPq5wlxjYUW"
    vectorDBUser: &vectorDBUser "dummy@dify.ai"
    vectorDBKey: &vectorDBKey "IVuubCz8zN3G502hUPbYlBpEsm2ndhGaDFgPO+8EhRErfvUpVm3WgoKd"

image:
  api:
    repository: langgenius/dify-api
    tag: "1.2.0"
    pullPolicy: IfNotPresent
    ## Optionally specify an array of imagePullSecrets.
    ## Secrets must be manually created in the namespace.
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    ##
    # pullSecrets:
    #   - myRegistryKeySecretName

  web:
    repository: langgenius/dify-web
    tag: "1.2.0"
    pullPolicy: IfNotPresent
    ## Optionally specify an array of imagePullSecrets.
    ## Secrets must be manually created in the namespace.
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    ##
    # pullSecrets:
    #   - myRegistryKeySecretName

  sandbox:
    repository: langgenius/dify-sandbox
    tag: "0.2.11"
    pullPolicy: IfNotPresent
    ## Optionally specify an array of imagePullSecrets.
    ## Secrets must be manually created in the namespace.
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    ##
    # pullSecrets:
    #   - myRegistryKeySecretName

  proxy:
    repository: ghcr.io/llmos-ai/mirrored-library-nginx
    tag: 1.24.0-alpine
    pullPolicy: IfNotPresent
    ## Optionally specify an array of imagePullSecrets.
    ## Secrets must be manually created in the namespace.
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    ##
    # pullSecrets:
    #   - myRegistryKeySecretName

  ssrfProxy:
    repository: ubuntu/squid
    tag: latest
    pullPolicy: IfNotPresent
    ## Optionally specify an array of imagePullSecrets.
    ## Secrets must be manually created in the namespace.
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    ##
    # pullSecrets:
    #   - myRegistryKeySecretName

  pluginDaemon:
    repository: langgenius/dify-plugin-daemon
    tag: 0.0.7-local
    pullPolicy: IfNotPresent
    ## Optionally specify an array of imagePullSecrets.
    ## Secrets must be manually created in the namespace.
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    ##
    # pullSecrets:
    #   - myRegistryKeySecretName

api:
  enabled: true
  replicas: 1
  resources:
    requests:
      cpu: 200m
      memory: 512Mi
    limits:
      cpu: 4000m
      memory: 8192Mi
  nodeSelector: {}
  affinity: {}
  tolerations: []
  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 100
    targetCPUUtilizationPercentage: 80
    # targetMemoryUtilizationPercentage: 80
  ## Configure extra options for API containers' liveness, readiness, and startup probes
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#configure-probes
  ## @param api.livenessProbe.enabled Enable livenessProbe on API nodes
  livenessProbe:
    enabled: true
    initialDelaySeconds: 30
    periodSeconds: 30
    timeoutSeconds: 5
    failureThreshold: 5
    successThreshold: 1
  ## @param api.readinessProbe.enabled Enable readinessProbe on API nodes
  readinessProbe:
    enabled: true
    initialDelaySeconds: 10
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 5
    successThreshold: 1
  ## @param api.startupProbe.enabled Enable startupProbe on API containers
  startupProbe:
    enabled: false
    initialDelaySeconds: 5
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 5
    successThreshold: 1
  ## @param api.customLivenessProbe Custom livenessProbe that overrides the default one
  customLivenessProbe: {}
  ## @param api.customReadinessProbe Custom readinessProbe that overrides the default one
  customReadinessProbe: {}
  ## @param api.customStartupProbe Custom startupProbe that overrides the default one
  customStartupProbe: {}
  # Configure Pods Security Context
  podSecurityContext: {}
  # Configure Container Security Context
  containerSecurityContext: {}
  extraEnv:
    # Apply your own Environment Variables if necessary.
    # Variables defined here take higher priority than those from `ConfigMap` generated given `.Values`
    # The direct approach
    # - name: LANG
    #   value: "C.UTF-8"
    #   - name: SECRET_KEY
    # Use existing k8s secrets
    #  - name: DB_PASSWORD
    #    valueFrom:
    #      secretKeyRef:
    #        name: my-secret
    #        key: DB_PASSWORD
    - name: CHECK_UPDATE_URL
      # Won't check for updates if left empty
      #   value: https://updates.dify.ai
      value: ""
    - name: CODE_MAX_NUMBER
      value: "9223372036854775807"
    - name: CODE_MIN_NUMBER
      value: "-9223372036854775808"
    - name: CODE_MAX_STRING_LENGTH
      value: "80000"
    - name: TEMPLATE_TRANSFORM_MAX_LENGTH
      value: "80000"
    - name: CODE_MAX_STRING_ARRAY_LENGTH
      value: "30"
    - name: CODE_MAX_OBJECT_ARRAY_LENGTH
      value: "30"
    - name: CODE_MAX_NUMBER_ARRAY_LENGTH
      value: "1000"
  service:
    port: 5001
    annotations: {}
    labels: {}
    clusterIP: ""
  # The log level for the application. Supported values are `DEBUG`, `INFO`, `WARNING`, `ERROR`, `CRITICAL`
  logLevel: INFO
  url:
    # The backend URL of the console API, used to concatenate the authorization callback.
    # If empty, it is the same domain. Example: https://api.console.dify.ai
    consoleApi: ""
    # The front-end URL of the console web, used to concatenate some front-end addresses and for CORS configuration use.
    # If empty, it is the same domain. Example: https://console.dify.ai
    consoleWeb: ""
    # Service API URL, used to display Service API Base URL to the front-end.
    # If empty, it is the same domain. Example: https://api.dify.ai
    serviceApi: ""
    # WebApp API backend URL, used to declare the back-end URL for the front-end API.
    # If empty, it is the same domain. Example: https://app.dify.ai
    appApi: ""
    # WebApp URL, used to display WebAPP API Base URL to the front-end. If empty, it is the same domain. Example: https://api.app.dify.ai
    appWeb: ""
    # File preview or download URL prefix, used to display the file preview
    # or download URL to the front-end or as a multi-modal model input;
    # In order to prevent others from forging, the image preview URL is signed and has a 5-minute expiration time.
    files: ""
    marketplaceApi: "https://marketplace.dify.ai"
    marketplace: "https://marketplace.dify.ai"
  mail:
    # default email sender from email address, if not given a specific address
    defaultSender: "YOUR EMAIL FROM (e.g.: no-reply <no-reply@dify.ai>)"
    # Mail type, supported values are `smtp`, `resend` https://docs.dify.ai/getting-started/install-self-hosted/environments#mail-related-configuration
    type: "resend"
    resend:
      # Resend API Key
      apiKey: "xxxx"
      # Resend API URL
      apiUrl: https://api.resend.com
    # SMTP Configuration
    smtp:
      server: "smtp.server.com"
      port: 465
      username: "YOUR EMAIL"
      password: "YOUR EMAIL PASSWORD"
      tls:
        enabled: true
        optimistic: false
  # When enabled, migrations will be executed prior to application startup and the application will start after the migrations have completed.
  migration: true
  # A secret key that is used for securely signing the session cookie and encrypting sensitive information on the database. You can generate a strong key using `openssl rand -base64 42`.
  secretKey: *secretKye
  ## Storage for `api` and `worker`
  ## Ignored if `.Values.externalS3.enabled` is true
  ##
  persistence:
    mountPath: "/app/api/storage"
    annotations:
      helm.sh/resource-policy: keep
    persistentVolumeClaim:
      existingClaim: ""
      ## Dify App Data Persistent Volume Storage Class
      ## If defined, storageClassName: <storageClass>
      ## If set to "-", storageClassName: "", which disables dynamic provisioning
      ## If undefined (the default) or set to null, no storageClassName spec is
      ##   set, choosing the default provisioner.
      ## ReadWriteMany access mode required for `api` and `worker`
      ##
      storageClass: "llmos-ceph-filesystem"
      accessModes: ReadWriteMany
      size: 5Gi
      subPath: ""
  ## Dify API ServiceAccount configuration
  ##
  serviceAccount:
    ## @param api.serviceAccount.create Specifies whether a ServiceAccount should be created
    ##
    create: false
    ## @param api.serviceAccount.name The name of the ServiceAccount to use.
    ## If not set and create is true, a name is generated using the common.names.fullname template
    ##
    name: ""
    ## @param api.serviceAccount.automountServiceAccountToken Allows auto mount of ServiceAccountToken on the serviceAccount created
    ##
    automountServiceAccountToken: false
    ## @param api.serviceAccount.annotations Additional custom annotations for the ServiceAccount
    ##
    annotations: {}

worker:
  enabled: true
  replicas: 1
  resources:
    requests:
      cpu: 100m
      memory: 200Mi
    limits:
      cpu: 2000m
      memory: 4096Mi
  nodeSelector: {}
  affinity: {}
  tolerations: []
  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 100
    targetCPUUtilizationPercentage: 80
    # targetMemoryUtilizationPercentage: 80
  ## Configure extra options for worker containers' liveness, readiness, and startup probes
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#configure-probes
  ## @param worker.customLivenessProbe Custom livenessProbe that overrides the default one
  customLivenessProbe: {}
  ## @param worker.customReadinessProbe Custom readinessProbe that overrides the default one
  customReadinessProbe: {}
  ## @param worker.customStartupProbe Custom startupProbe that overrides the default one
  customStartupProbe: {}
  # Configure Pods Security Context
  podSecurityContext: {}
  # Configure Container Security Context
  containerSecurityContext: {}
  extraEnv:
  # Apply your own Environment Variables if necessary.
  # Variables defined here take higher priority than those from `ConfigMap` generated given `.Values`
  # The direct approach
  # - name: LANG
  #   value: "C.UTF-8"
  #   - name: SECRET_KEY
  # Use existing k8s secrets
  #  - name: DB_PASSWORD
  #    valueFrom:
  #      secretKeyRef:
  #        name: my-secret
  #        key: DB_PASSWORD
  logLevel: INFO
  ## Dify Worker ServiceAccount configuration
  ##
  serviceAccount:
    ## @param worker.serviceAccount.create Specifies whether a ServiceAccount should be created
    ##
    create: false
    ## @param worker.serviceAccount.name The name of the ServiceAccount to use.
    ## If not set and create is true, a name is generated using the common.names.fullname template
    ##
    name: ""
    ## @param worker.serviceAccount.automountServiceAccountToken Allows auto mount of ServiceAccountToken on the serviceAccount created
    ##
    automountServiceAccountToken: false
    ## @param worker.serviceAccount.annotations Additional custom annotations for the ServiceAccount
    ##
    annotations: {}

proxy:
  enabled: true
  replicas: 1
  resources:
    requests:
      cpu: 10m
      memory: 20Mi
    limits:
      cpu: 200m
      memory: 512Mi
  nodeSelector: {}
  affinity: {}
  tolerations: []
  ## Configure extra options for proxy containers' liveness, readiness, and startup probes
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#configure-probes
  ## @param proxy.customLivenessProbe Custom livenessProbe that overrides the default one
  customLivenessProbe: {}
  ## @param proxy.customReadinessProbe Custom readinessProbe that overrides the default one
  customReadinessProbe: {}
  ## @param proxy.customStartupProbe Custom startupProbe that overrides the default one
  customStartupProbe: {}
  ## @param proxy.clientMaxBodySize Custom client_max_body_size param nginx default: 15m
  clientMaxBodySize: ""
  # Configure Pods Security Context
  podSecurityContext: {}
  # Configure Container Security Context
  containerSecurityContext: {}
  extraEnv:
  # Apply your own Environment Variables if necessary
  # - name: LANG
  #   value: "C.UTF-8"
  log:
    persistence:
      ## If true, create/use a Persistent Volume Claim for log
      ## If false, flush logs to stdout & stderr
      ##
      enabled: false
      mountPath: "/var/log/nginx"
      annotations:
        helm.sh/resource-policy: keep
      persistentVolumeClaim:
        existingClaim: ""
        ## Nginx Logs Persistent Volume Storage Class
        ## If defined, storageClassName: <storageClass>
        ## If set to "-", storageClassName: "", which disables dynamic provisioning
        ## If undefined (the default) or set to null, no storageClassName spec is
        ##   set, choosing the default provisioner.
        ## ReadWriteMany access mode required for nginx
        ##
        storageClass: ""
        accessModes: ReadWriteOnce
        size: 1Gi
        subPath: ""
  service:
    port: 80
    annotations: {}
    labels: {}
    clusterIP: ""
  ## Proxy ServiceAccount configuration
  ##
  serviceAccount:
    ## @param proxy.serviceAccount.create Specifies whether a ServiceAccount should be created
    ##
    create: false
    ## @param proxy.serviceAccount.name The name of the ServiceAccount to use.
    ## If not set and create is true, a name is generated using the common.names.fullname template
    ##
    name: ""
    ## @param proxy.serviceAccount.automountServiceAccountToken Allows auto mount of ServiceAccountToken on the serviceAccount created
    ##
    automountServiceAccountToken: false
    ## @param proxy.serviceAccount.annotations Additional custom annotations for the ServiceAccount
    ##
    annotations: {}

web:
  enabled: true
  replicas: 1
  resources:
    requests:
      cpu: 10m
      memory: 20Mi
    limits:
      cpu: 200m
      memory: 512Mi
  nodeSelector: {}
  affinity: {}
  tolerations: []
  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 100
    targetCPUUtilizationPercentage: 80
    # targetMemoryUtilizationPercentage: 80
  ## Configure extra options for web containers' liveness, readiness, and startup probes
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#configure-probes
  ## @param web.livenessProbe.enabled Enable livenessProbe on web nodes
  livenessProbe:
    enabled: true
    initialDelaySeconds: 5
    periodSeconds: 30
    timeoutSeconds: 5
    failureThreshold: 5
    successThreshold: 1
  ## @param web.readinessProbe.enabled Enable readinessProbe on web nodes
  readinessProbe:
    enabled: true
    initialDelaySeconds: 5
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 5
    successThreshold: 1
  ## @param web.startupProbe.enabled Enable startupProbe on web containers
  startupProbe:
    enabled: false
    initialDelaySeconds: 5
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 5
    successThreshold: 1
  ## @param web.customLivenessProbe Custom livenessProbe that overrides the default one
  customLivenessProbe: {}
  ## @param web.customReadinessProbe Custom readinessProbe that overrides the default one
  customReadinessProbe: {}
  ## @param web.customStartupProbe Custom startupProbe that overrides the default one
  customStartupProbe: {}
  # Configure Pods Security Context
  podSecurityContext: {}
  # Configure Container Security Context
  containerSecurityContext: {}
  extraEnv:
    # Apply your own Environment Variables if necessary
    - name: EDITION
      value: "SELF_HOSTED"
  service:
    port: 3000
    annotations: {}
    labels: {}
    clusterIP: ""
  ## Web ServiceAccount configuration
  ##
  serviceAccount:
    ## @param web.serviceAccount.create Specifies whether a ServiceAccount should be created
    ##
    create: false
    ## @param web.serviceAccount.name The name of the ServiceAccount to use.
    ## If not set and create is true, a name is generated using the common.names.fullname template
    ##
    name: ""
    ## @param web.serviceAccount.automountServiceAccountToken Allows auto mount of ServiceAccountToken on the serviceAccount created
    ##
    automountServiceAccountToken: false
    ## @param web.serviceAccount.annotations Additional custom annotations for the ServiceAccount
    ##
    annotations: {}
  ## @param web.enableServiceLinks Disable this feature if additional environment variables would lead to `E2BIG` errors in case frontend were managed by `pm2`
  ##
  enableServiceLinks: false

sandbox:
  enabled: true
  replicas: 1
  resources:
    requests:
      cpu: 10m
      memory: 20Mi
    limits:
      cpu: 200m
      memory: 512Mi
  nodeSelector: {}
  affinity: {}
  tolerations: []
  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 100
    targetCPUUtilizationPercentage: 80
    # targetMemoryUtilizationPercentage: 80
  ## Configure extra options for sandbox containers' liveness, readiness, and startup probes
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#configure-probes
  ## @param sandbox.livenessProbe.enabled Enable livenessProbe on sandbox nodes
  livenessProbe:
    enabled: true
    initialDelaySeconds: 1
    periodSeconds: 5
    timeoutSeconds: 5
    failureThreshold: 2
    successThreshold: 1
  ## @param sandbox.readinessProbe.enabled Enable readinessProbe on sandbox nodes
  readinessProbe:
    enabled: true
    initialDelaySeconds: 10
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 2
    successThreshold: 1
  ## @param sandbox.startupProbe.enabled Enable startupProbe on sandbox containers
  startupProbe:
    enabled: false
    initialDelaySeconds: 5
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 2
    successThreshold: 1
  ## @param sandbox.customLivenessProbe Custom livenessProbe that overrides the default one
  customLivenessProbe: {}
  ## @param sandbox.customReadinessProbe Custom readinessProbe that overrides the default one
  customReadinessProbe: {}
  ## @param sandbox.customStartupProbe Custom startupProbe that overrides the default one
  customStartupProbe: {}
  # Configure Pods Security Context
  podSecurityContext: {}
  # Configure Container Security Context
  containerSecurityContext: {}
  extraEnv:
    # Apply your own Environment Variables if necessary
    # - name: LANG
    #   value: "C.UTF-8"
    - name: WORKER_TIMEOUT
      value: "15"
  service:
    port: 8194
    annotations: {}
    labels: {}
    clusterIP: ""
  auth:
    apiKey: "dify-sandbox"
  privileged: false
  ## Sandbox ServiceAccount configuration
  ##
  serviceAccount:
    ## @param sandbox.serviceAccount.create Specifies whether a ServiceAccount should be created
    ##
    create: false
    ## @param sandbox.serviceAccount.name The name of the ServiceAccount to use.
    ## If not set and create is true, a name is generated using the common.names.fullname template
    ##
    name: ""
    ## @param sandbox.serviceAccount.automountServiceAccountToken Allows auto mount of ServiceAccountToken on the serviceAccount created
    ##
    automountServiceAccountToken: false
    ## @param sandbox.serviceAccount.annotations Additional custom annotations for the ServiceAccount
    ##
    annotations: {}

ssrfProxy:
  enabled: false
  replicas: 1
  resources:
    requests:
      cpu: 10m
      memory: 20Mi
    limits:
      cpu: 200m
      memory: 512Mi
  nodeSelector: {}
  affinity: {}
  tolerations: []
  ## Configure extra options for ssrf proxy containers' liveness, readiness, and startup probes
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#configure-probes
  ## @param ssrfProxy.customLivenessProbe Custom livenessProbe that overrides the default one
  customLivenessProbe: {}
  ## @param ssrfProxy.customReadinessProbe Custom readinessProbe that overrides the default one
  customReadinessProbe: {}
  ## @param ssrfProxy.customStartupProbe Custom startupProbe that overrides the default one
  customStartupProbe: {}
  # Configure Pods Security Context
  podSecurityContext: {}
  # Configure Container Security Context
  containerSecurityContext: {}
  extraEnv:
  # Apply your own Environment Variables if necessary
  # - name: LANG
  #   value: "C.UTF-8"
  log:
    persistence:
      ## If true, create/use a Persistent Volume Claim for log
      ## If false, flush logs to stdout & stderr
      ##
      enabled: false
      mountPath: "/var/log/squid"
      annotations:
        helm.sh/resource-policy: keep
      persistentVolumeClaim:
        existingClaim: ""
        ## Squid Logs Persistent Volume Storage Class
        ## If defined, storageClassName: <storageClass>
        ## If set to "-", storageClassName: "", which disables dynamic provisioning
        ## If undefined (the default) or set to null, no storageClassName spec is
        ##   set, choosing the default provisioner.
        ## ReadWriteMany access mode required for squid
        ##
        storageClass: "llmos-ceph-filesystem"
        accessModes: ReadWriteMany
        size: 1Gi
        subPath: ""
  service:
    port: 3128
    annotations: {}
    labels: {}
    clusterIP: ""
  ## ssrfProxy ServiceAccount configuration
  ##
  serviceAccount:
    ## @param ssrfProxy.serviceAccount.create Specifies whether a ServiceAccount should be created
    ##
    create: false
    ## @param ssrfProxy.serviceAccount.name The name of the ServiceAccount to use.
    ## If not set and create is true, a name is generated using the common.names.fullname template
    ##
    name: ""
    ## @param ssrfProxy.serviceAccount.automountServiceAccountToken Allows auto mount of ServiceAccountToken on the serviceAccount created
    ##
    automountServiceAccountToken: false
    ## @param ssrfProxy.serviceAccount.annotations Additional custom annotations for the ServiceAccount
    ##
    annotations: {}

pluginDaemon:
  enabled: true
  replicas: 1
  resources:
    requests:
      cpu: 100m
      memory: 200Mi
    limits:
      cpu: 2000m
      memory: 4096Mi
  nodeSelector: {}
  affinity: {}
  tolerations: []
  ## Configure extra options for plugin daemon containers' liveness, readiness, and startup probes
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#configure-probes
  ## @param pluginDaemon.customLivenessProbe Custom livenessProbe that overrides the default one
  customLivenessProbe: {}
  ## @param pluginDaemon.customReadinessProbe Custom readinessProbe that overrides the default one
  customReadinessProbe: {}
  ## @param pluginDaemon.customStartupProbe Custom startupProbe that overrides the default one
  customStartupProbe: {}
  # Configure Pods Security Context
  podSecurityContext: {}
  # Configure Container Security Context
  containerSecurityContext: {}
  extraEnv:
  # Apply your own Environment Variables if necessary
  # - name: LANG
  #   value: "C.UTF-8"
  service:
    ports:
      daemon: 5002
      # Leave it unspecified in order NOT to expose port for remote installation as a `Service`.
      pluginInstall:
      # pluginInstall: 5003
    annotations: {}
    labels: {}
    clusterIP: ""
  auth:
    serverKey: "lYkiYYT6owG+71oLerGzA7GXCgOT++6ovaezWAjpCjf+Sjc3ZtU+qUEi"
    # A separate key for interactions between `api`(`worker`) and `pluginDaemon`
    difyApiKey: "QaHbTe77CtuXmsfyhR7+vRjI/+XbV1AaFy691iy+kGDv2Jvy0/eAh8Y1"
  ## Storage for `pluginDaemon`
  ## Ignored if external object storage were configured via `.Values.externalS3` sections.
  ##
  persistence:
    mountPath: "/app/storage"
    annotations:
      helm.sh/resource-policy: keep
    persistentVolumeClaim:
      existingClaim: ""
      ## Dify Plugin Daemon Persistent Volume Storage Class
      ## If defined, storageClassName: <storageClass>
      ## If set to "-", storageClassName: "", which disables dynamic provisioning
      ## If undefined (the default) or set to null, no storageClassName spec is
      ##   set, choosing the default provisioner.
      ## ReadWriteMany access mode required for `pluginDaemon`
      ##
      storageClass: "llmos-ceph-filesystem"
      accessModes: ReadWriteMany
      size: 5Gi
      subPath: ""
  marketplace:
    enabled: true
    # Takes effect only if built-in `nginx` were enabled
    # If enabled, route marketplace api call to built-in `nginx` and strip headers for tracking.
    # https://github.com/BorisPolonsky/dify-helm/pull/131
    apiProxyEnabled: false
  ## pluginDaemon ServiceAccount configuration
  ##
  serviceAccount:
    ## @param pluginDaemon.serviceAccount.create Specifies whether a ServiceAccount should be created
    ##
    create: false
    ## @param pluginDaemon.serviceAccount.name The name of the ServiceAccount to use.
    ## If not set and create is true, a name is generated using the common.names.fullname template
    ##
    name: ""
    ## @param pluginDaemon.serviceAccount.automountServiceAccountToken Allows auto mount of ServiceAccountToken on the serviceAccount created
    ##
    automountServiceAccountToken: false
    ## @param pluginDaemon.serviceAccount.annotations Additional custom annotations for the ServiceAccount
    ##
    annotations: {}

postgresql:
  enabled: true
  name: postgres
  global:
    storageClass: ""
    postgresql:
      auth:
        postgresPassword: *defaultPassword
        username: ""
        password: ""
        database: "dify"
  ## @param architecture PostgreSQL architecture (`standalone` or `replication`)
  ##
  architecture: replication
  ## Replication configuration
  ## Ignored if `architecture` is `standalone`
  ##
  primary:
    resources:
      requests:
        cpu: 200m
        memory: 256Mi
      limits:
        cpu: 3
        memory: 1024Mi
    persistence:
      enabled: true
      storageClass: ""
      accessModes:
        - ReadWriteOnce
      size: 8Gi

    ## @param primary.affinity Affinity for PostgreSQL primary pods assignment
    ## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
    ## Note: primary.podAffinityPreset, primary.podAntiAffinityPreset, and primary.nodeAffinityPreset will be ignored when it's set
    ##
    affinity: {}

    ## @param primary.tolerations Tolerations for PostgreSQL primary pods assignment
    ## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
    ##
    tolerations: []

  ## @section PostgreSQL read only replica parameters (only used when `architecture` is set to `replication`)
  ##
  readReplicas:
    name: read
    replicaCount: 1
    resources:
      requests:
        cpu: 100m
        memory: 128Mi
      limits:
        cpu: 2
        memory: 1024Mi
    persistence:
      enabled: true
      storageClass: ""
      accessModes:
        - ReadWriteOnce
      size: 8Gi

    ## @param readReplicas.affinity Affinity for PostgreSQL read only pods assignment
    ## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
    ## Note: primary.podAffinityPreset, primary.podAntiAffinityPreset, and primary.nodeAffinityPreset will be ignored when it's set
    ##
    affinity: {}

    ## @param readReplicas.tolerations Tolerations for PostgreSQL read only pods assignment
    ## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
    ##
    tolerations: []

weaviate:
  enabled: true
  # Scale replicas of Weaviate. Note that as of v1.8.0 dynamic scaling is limited
  # to cases where no data is imported yet. Scaling down after importing data may
  # break usability. Full dynamic scalability will be added in a future release.
  replicas: 1
  resources:
    requests:
      cpu: 100m
      memory: 200Mi
    limits:
      cpu: 2
      memory: 4096Mi

  # The Persistent Volume Claim settings for Weaviate. If there's a
  # storage.fullnameOverride field set, then the default pvc will not be
  # created, instead the one defined in fullnameOverride will be used
  storage:
    size: 32Gi
    storageClassName: ""

  # The service controls how weaviate is exposed to the outside world. If you
  # don't want a public load balancer, you can also choose 'ClusterIP' to make
  # weaviate only accessible within your cluster.
  service:
    name: weaviate
    # type: LoadBalancer
    type: ClusterIP

  grpcService:
    enabled: true
    name: weaviate-grpc
    # type: LoadBalancer
    type: ClusterIP

  # Weaviate Config
  #
  # The following settings allow you to customize Weaviate to your needs, for
  # example set authentication and authorization options. See weaviate docs
  # (https://www.weaviate.io/developers/weaviate/) for all
  # configuration.
  authentication:
    anonymous_access:
      enabled: false
    # This configuration allows to add API keys to Weaviate. This configuration allows only
    # plain text API Keys, if you want to store the API Keys in a Kubernetes secret you can
    # configure the same configuration with ENV Vars. Read the `env` section below on what
    # needs to be configured. If using ENV Vars over this make sure to comment out the whole
    # `apikey` section (as it is by default). ENV Vars has priority over this config.
    apikey:
      enabled: true
      # Any number of allowed API Keys as plain text
      allowed_keys:
        - *vectorDBKey
      users:
        - *vectorDBUser
  authorization:
    admin_list:
      enabled: true
      users:
        - *vectorDBUser

  # Insert any custom environment variables or envSecrets by putting the exact name
  # and desired value into the settings below. Any env name passed will be automatically
  # set for the statefulSet.
  env:
    CLUSTER_GOSSIP_BIND_PORT: 7000
    CLUSTER_DATA_BIND_PORT: 7001
    # The aggressiveness of the Go Garbage Collector. 100 is the default value.
    GOGC: 100

    # Expose metrics on port 2112 for Prometheus to scrape
    PROMETHEUS_MONITORING_ENABLED: false

    # Set a MEM limit for the Weaviate Pod so it can help you both increase GC-related
    # performance as well as avoid GC-related out-of-memory (“OOM”) situations
    # GOMEMLIMIT: 6GiB

    # Maximum results Weaviate can query with/without pagination
    # NOTE: Affects performance, do NOT set to a very high value.
    # The default is 100K
    QUERY_MAXIMUM_RESULTS: 100000

    # whether to enable vector dimensions tracking metric
    TRACK_VECTOR_DIMENSIONS: false

    # whether to re-index/-compute the vector dimensions metric (needed if upgrading from weaviate < v1.16.0)
    REINDEX_VECTOR_DIMENSIONS_AT_STARTUP: false

    ##########################
    # API Keys with ENV Vars #
    ##########################
    # If using ENV Vars to set up API Keys make sure to have `authentication.apikey` block commented out
    # to avoid any future changes. ENV Vars has priority over the config above `authentication.apikey`.
    # If using `authentication.apikey `the below ENV Vars will be used because they have priority,
    # so comment them out to avoid any future changes.
    # Enables API key authentication. If it is set to 'false' the AUTHENTICATION_APIKEY_ALLOWED_KEYS
    # and AUTHENTICATION_APIKEY_USERS will not have any effect.
    # AUTHENTICATION_APIKEY_ENABLED: 'true'

    # List one or more keys, separated by commas. Each key corresponds to a specific user identity below.
    # If you want to use a kubernetes secret for the API Keys comment out this Variable and use the one in `envSecrets` below
    # AUTHENTICATION_APIKEY_ALLOWED_KEYS: 'jane-secret-key,ian-secret-key'  (plain text)

    # List one or more user identities, separated by commas. You can have only one User for all the keys or one user per key.
    # The User/s can be a simple name or an email, no matter if it exists or not.
    # NOTE: Make sure to add the users to the authorization above overwise they will not be allowed to interact with Weaviate.
    # AUTHENTICATION_APIKEY_USERS: 'jane@doe.com,ian-smith'
    AUTHENTICATION_APIKEY_ENABLED: "true"
    AUTHENTICATION_APIKEY_ALLOWED_KEYS: *vectorDBKey
    AUTHENTICATION_APIKEY_USERS: *vectorDBUser
    AUTHORIZATION_ADMINLIST_ENABLED: "true"
    AUTHORIZATION_ADMINLIST_USERS: *vectorDBUser

## dify service
service:
  name: http-dify
  type: ClusterIP
  port: 80

ingress:
  enabled: false
  className: ""
  annotations:
    {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
    # nginx.ingress.kubernetes.io/backend-protocol: HTTP
    # nginx.ingress.kubernetes.io/proxy-body-size: 15m
  # nginx.ingress.kubernetes.io/ssl-redirect: "true"
  hosts:
    - host: dify-example.local
      paths:
        - path: /
          pathType: ImplementationSpecific
    # - host: dify-example2.local
    #   paths:
    #     - path: /
    #       pathType: Prefix
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - dify-example.local

# Global node selector
# If set, this will apply to all dify components
# Individual components can be set to a different node selector
nodeSelector: {}

# Global tolerations
# If set, this will apply to all dify components
# Individual components can be set to a different tolerations
tolerations: []

# Global affinity
# If set, this will apply to all dify components
# Individual components can be set to a different affinity
affinity: {}

redis:
  enabled: true
  ## @section Redis&reg; common configuration parameters
  ## https://github.com/bitnami/containers/tree/main/bitnami/redis#configuration
  ##

  ## @param architecture Redis&reg; architecture. Allowed values: `standalone` or `replication`
  ##
  architecture: replication
  ## Redis&reg; Authentication parameters
  ## ref: https://github.com/bitnami/containers/tree/main/bitnami/redis#setting-the-server-password-on-first-run
  ##
  auth:
    ## @param auth.enabled Enable password authentication
    ##
    enabled: true
    ## @param auth.sentinel Enable password authentication on sentinels too
    ##
    sentinel: true
    ## @param auth.password Redis&reg; password
    ## Defaults to a random 10-character alphanumeric string if not set
    ##
    password: *defaultPassword
    ## @param auth.existingSecret The name of an existing secret with Redis&reg; credentials
    ## NOTE: When it's set, the previous `auth.password` parameter is ignored
    ##
    existingSecret: ""
    ## @param auth.existingSecretPasswordKey Password key to be retrieved from existing secret
    ## NOTE: ignored unless `auth.existingSecret` parameter is set
    ##
    existingSecretPasswordKey: ""
    ## @param auth.usePasswordFiles Mount credentials as files instead of using an environment variable
    ##
    usePasswordFiles: false

  ## @section Redis&reg; master configuration parameters
  ##

  master:
    ## @param master.count Number of Redis&reg; master instances to deploy (experimental, requires additional configuration)
    ##
    count: 1

  replica:
    ## @param replica.replicaCount Number of Redis&reg; replicas to deploy
    ##
    replicaCount: 1

  ## @section useExternalDNS Parameters
  ##
  ## @param useExternalDNS.enabled Enable various syntax that would enable external-dns to work.  Note this requires a working installation of `external-dns` to be usable.
  ## @param useExternalDNS.additionalAnnotations Extra annotations to be utilized when `external-dns` is enabled.
  ## @param useExternalDNS.annotationKey The annotation key utilized when `external-dns` is enabled. Setting this to `false` will disable annotations.
  ## @param useExternalDNS.suffix The DNS suffix utilized when `external-dns` is enabled.  Note that we prepend the suffix with the full name of the release.
  ##
  useExternalDNS:
    enabled: false
    suffix: ""
    annotationKey: external-dns.alpha.kubernetes.io/
    additionalAnnotations: {}

###################################
# External postgres
# - these configs are only used when `externalPostgres.enabled` is true
###################################
externalPostgres:
  enabled: false
  username: "postgres"
  password: "difyai123456"
  address: localhost
  port: 5432
  database:
    api: "dify"
    pluginDaemon: "dify_plugin"
  maxOpenConns: 20
  maxIdleConns: 5

###################################
# External S3
# - these configs are only used when `externalS3.enabled` is true
###################################
externalS3:
  enabled: false
  endpoint: "https://xxx.r2.cloudflarestorage.com"
  accessKey: "ak-difyai"
  secretKey: "sk-difyai"
  useSSL: false
  bucketName:
    # Shared storage for `api` and `worker`
    api: "difyai"
    # If specifed, `pluginDaemon` will use this bucket instead of binding `PersistentVolume` for data persistence (only used when `externalS3.enabled` is set to `true`).
    pluginDaemon:
  useIAM: false
  region: "us-east-1"

###################################
# External Azure Blob Storage
# - these configs are only used when `externalS3.enabled` is false and `externalAzureBlobStorage.enabled` is true
###################################
externalAzureBlobStorage:
  enabled: false
  url: "https://<your_account_name>.blob.core.windows.net"
  account: "https://xxx.r2.cloudflarestorage.com"
  key: "difyai"
  container: "difyai-container"

###################################
# External OSS
# - these configs are only used when both `externalS3.enabled` and `externalAzureBlobStorage.enabled` are false and `externalOSS.enabled` is true
###################################
externalOSS:
  enabled: false
  endpoint: "https://oss-ap-southeast-1-internal.aliyuncs.com"
  accessKey: "ak-difyai"
  secretKey: "sk-difyai"
  region: "ap-southeast-1"
  bucketName: "difyai"
  authVersion: v4
  path: "your-path"

###################################
# External Google Cloud Storage
# - these configs are only used when `externalS3.enabled` and `externalAzureBlobStorage.enabled` and `externalOSS.enabled` are false and `externalGCS.enabled` is true
###################################
externalGCS:
  enabled: false
  bucketName: "difyai"
  serviceAccountJsonBase64: ""

###################################
# External TENCENT COS
# - these configs are only used when `externalS3.enabled` and `externalAzureBlobStorage.enabled` and `externalOSS.enabled` and `externalGCS.enabled` are false and `externalCOS.enabled` is true
###################################
externalCOS:
  enabled: false
  secretKey: "your-secret-key"
  secretId: "your-secret-id"
  region: "your-region"
  bucketName:
    api: "your-bucket-name"
    # If specifed, `pluginDaemon` will use this bucket instead of binding `PersistentVolume` for data persistence (only used when `externalCOS.enabled` is set to `true`).
    pluginDaemon:
  scheme: "your-scheme"

###################################
# External HUAWEI OBS
# - these configs are only used when `externalS3.enabled` and `externalAzureBlobStorage.enabled` and `externalOSS.enabled` and `externalGCS.enabled` and `externalCOS.enabled` are false and `externalOBS.enabled` is true
###################################
externalOBS:
  enabled: false
  secretKey: "your-secret-key"
  secretId: "your-secret-id"
  bucketName: "your-bucket-name"
  server: "your-server"

###################################
# External Redis
# - these configs are only used when `externalRedis.enabled` is true
###################################
externalRedis:
  enabled: false
  host: "redis.example"
  port: 6379
  username: ""
  password: "difyai123456"
  useSSL: false

###################################
# External Weaviate
# - these configs take effect when `externalWeaviate.enabled` is true
###################################
externalWeaviate:
  enabled: false
  endpoint: "http://weaviate:8080"
  apiKey: "WVF5YThaHlkYwhGUSmCRgsX3tD5ngdN8pkih"

###################################
# External Qdrant
# - these configs take effect only if `externalWeaviate.enabled` is `false` and `externalQdrant.enabled` is `true`
###################################
externalQdrant:
  enabled: false
  endpoint: "https://your-qdrant-cluster-url.qdrant.tech/"
  apiKey: "ak-difyai"
  timeout: 20
  grpc:
    enabled: false
    port: 6334

###################################
# External Milvus
# - these configs take effect only if both `externalWeaviate.enabled` and `externalQdrant.enabled` are set as `false` and `externalMilvus.enabled` is `true`
###################################
externalMilvus:
  enabled: false
  uri: "http://your-milvus.domain:19530"
  database: 'default'
  token: ""
  user: ""
  password: ""

###################################
# External Pgvector
# - these configs take effect only if both `externalWeaviate.enabled`, `externalQdrant.enabled` and `externalMilvus.enabled` are set as `false` and `externalPgvector.enabled` is `true`
###################################
externalPgvector:
  enabled: false
  username: "postgres"
  password: "difyai123456"
  address: "pgvector"
  port: 5432
  dbName: dify

###################################
# External Tencent Vector DB
# - these configs take effect only if both `externalWeaviate.enabled`, `externalQdrant.enabled` and `externalMilvus.enabled` and `externalPgvector.enabled` are set as `false` and `externalTencentVectorDB.enabled` is `true`
###################################
externalTencentVectorDB:
  enabled: false
  url: "your-tencent-vector-db-url"
  apiKey: "your-tencent-vector-db-api-key"
  timeout: 30
  username: "root"
  database: "dify"
  shard: 1
  replicas: 2

###################################
# External MyScaleDB Vector DB
# - these configs take effect only if both `externalWeaviate.enabled`, `externalQdrant.enabled` and `externalMilvus.enabled` and `externalPgvector.enabled` and `externalTencentVectorDB.enabled` are set as `false` and `externalMyScaleDB.enabled` is `true`
###################################
externalMyScaleDB:
  enabled: false
  host: "myscale"
  port: 8123
  user: "default"
  password: ""
  database: "dify"
  ftsParams: ""

###################################
# External TableStore Vector DB
# - these configs take effect only if both `externalWeaviate.enabled`, `externalQdrant.enabled` and `externalMilvus.enabled` and `externalPgvector.enabled` and `externalTencentVectorDB.enabled` and `externalMyScaleDB.enabled` are set as `false` and `externalTableStore.enabled` is `true`
###################################
externalTableStore:
  enabled: false
  endpoint: "endpoint"
  instanceName: "instance-name"
  accessKeyId: "your-secret-id"
  accessKeySecret: "your-secret-key"
